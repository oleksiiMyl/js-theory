## Class

То, что JavaScript позволяет организовать наследование в определенной форме с помощью прототипов, само по себе
замечательно. Но общим желанием всех разработчиков, особенно с опытом программирования в классическом
объектно-ориентированном стиле, является упрощение или абстракция системы наследования в JavaScript до более
знакомого им уровня.

Это неизбежно приводит к такому понятию, как классы, хотя в JavaScript классическая поддержка наследования в
естественном виде не реализована. В ответ на эти потребности появился ряд библиотек JavaScript, где наследование
имитируется в классическом виде. Но поскальку в каждой библиотеке классы реализуются по-своему, комитет по
развитию стандарта ECMAScript стандартизировал синтаксис для имитации наследования на основе классов. Обратите
внимание на слово "имитация". Несмотря на то что, программируя на JavaScript, теперь можно пользоваться ключевым
словом `class`, базовая реализация наследования по-прежнему основываясь на прототипах!

___

### Применение ключевого слова *class*

В стандарт ES6 языка JavaScript было введено ключевое слово `class`, представляющее намного более изящный способ
создания объектов и реализации наследования, чем его реализация вручную с помощью прототипов. Пользоваться
ключевым словом `class` нетрудно, как показано в примере:

    class Ninja {
        constructor(name) {
            this.name = name;
        }
        
        swingSword() {
            return true;
        }
    }
    
    const ninja = new Ninja("Yoshi");
    
    ninja instanceOf Ninja;     // true
    ninja.name === "Yoshi";     // true
    ninja.swingSword();         // true

В примере кода класс `Ninja` создается с помощью ключевого слова *class*. При создании классов в стандарте ES6 можно
явным образом определить функцию `constructor()`, которая будет вызываться при получении экземпляра объекта (в данном
случае типа `Ninja`). В теле конструктора можно получить доступ к вновь созданному экземпляру с помощью ключевого
слова `this` и без особого труда ввести новые свойства вроде `name`, а в теле самого класса - определить методы,
которые станут доступными всем экземплярам этого класса.

___

### Классы как синтаксическое удобство

Как упоминалось ранее, несмотря на введение ключегого слова `class` в стандарт ES6, интерпретатор JavaScript
по-прежнему работает на основе прототипов. А классы служат лишь синтаксическим удобством, упрощающим имитацию
настоящих классов в JavaScript.

Код выше можно функционально приравнять к следующему коду в стандарте ES5:

    function Ninja(name) {
        this.name = name;
    }
    
    Ninja.prototype.swingSword = function() {
        return true;
    }

Как видите, в новых классах, появившихся в стандарте ES6, нет ничего особенного. Их код выглядит более изящно, хотя
он и основывается на тех же принципах и понятиях, что и код в стандарте ES5.

___

### Статические методы

В предыдущих примерах было показано, каким образом определяются методы объектов (прототипные методы), доступные
всем экземплярам объектов. Помимо таких методов, в классических объектно-ориентированных языках программирования
вроде Java применяются статические методы, определяемые на уровне классов. В качестве примера рассмотрим код:

    class Ninja {
        constructor(name, level) {
            this.name = name;
            this.level = level;
        }
        
        swingSword() {
            return true;
        }
        
        static compare(ninja1, ninja2) {
            return ninja1.level - ninja2.level;
        }
    }
    
    const ninja1 = new Ninja("Yoshi", 4);
    const ninja2 = new Ninja("Hattori", 3);
    
    Ninja.compare(ninja1, ninja2) > 0;      // true

Статический метод `compare()`, сравнивающий уровни мастерства двух ниндзя, определяется на уровне класса, а не
экземпляра! По-этому недоступен из экземпляра `ninja`, но доступен из класса `Ninja`.

Статические методы могут быть реализованы и в коде, где стандарт ES6 не используется. Но для этого придется
вспомнить, что классы реализуются через функции. А поскольку статические методы действуют на уровне класса, то их
можно реализовать, выгодно воспользовавшись функциями в качестве объектов высшего порядка и введя свойсто метода в
функцию-конструктор, как показано в следующем примере кода:

    function Ninja(){}
    
    Ninja.compare = function(ninja1, ninja2){ ... }

___

### Реализация наследования

Откровенно говоря, осуществить наследование в коде до ES6 не так-то просто. Обратимся за конкретным примерам снова к
людям, представленным объектами типа `Person`, и ниндзя, представленным объектами типа `Ninja`, как показано в
следующем фрагменте кода:

    function Person() {}
    Person.prototype.dance = function() {};
    
    function Ninja() {}
    Ninja.prototype = new Person();
    
    Object.defineProperty(Ninja.prototype, "constructor", {
        enumerable: false,
        value: Ninja,
        writable: true
    });

В данном коде обращает на себя внимание следующее: методы, доступные экземплярам, должны быть непосредственно
введены в прототип функции-конструктора, как это сделано с методом `dance()` и конструктором объектов типа `Person`.
Если же требуется реализовать наследование, то придется задать прототип производного класса для наследования базового
класса. В данном случае новый экземпляр типа `Person` присваивается объекту типа `Ninja.prototype`. К сожалению,
в результате этой операции теряется свойство `constructor` прототипа, и поэтому его приходится восстанавливать с
помощью метода `Object.defineProperty()`. Как видите, пытаясь достичь такого относительно простого и
распространенного языкового средства, как наследование, необходимо принимать во внимание многие факторы. Правда,
начиная со стандарта ES6, дело значительно упростилось.

В примере кода показано, насколько просто можно теперь реализовать наследование в JavaScript:

    class Person {
        constructor(name) {
            this.name = name;
        }
        
        dance() {
            return true;
        }
    }
    
    class Ninja extends Person {
        constructor(name, weapon) {
            super(name);
            this.weapon = weapon;
        }
        
        wieldWeapon() {
            return true;
        }
    }
    
    const person = new Person("Bob");
    
    const ninja = new Ninja("Yoshi", "knife");
    
    person instanceOf Person;       // true
    ninja instanceOf Ninja;         // true
    ninja instanceOf Person;        // true
    person instanceOf Ninja;        // false
    "wieldWeapon" in person;        // false
    ninja.wieldWeapon();            // true
    ninja.dance();                  // true

В этом коде демонстрируется, каким образом наследование достигается в стандарте ES6. В частности, для наследования
одного класса от другого применяется ключевое слово `extends`. В конструкторе производного класса `Ninja` c
помощью ключевого слова `super` вызывается конструктор базового класса `Person`.

___

### ES6 vs ES5

Для закрепления материала, просмотрим еще раз как класс можно преобразовать в стандарт ES5:

    class Warrior {
        constructor(weapon) {
            this.weapon = weapon;
        }
        
        wield() {
            return "Wielding " + this.weapon;
        }
        
        static duel(warrior1, warrior2) {
            return warrior1.wield() + " " + warrior2.wield();
        }
    }

Этот фрагмент кода можно преобразовать следующим образом:

    function Warrior(weapon) {
        this.weapon = weapon;
    }
    
    Warrior.prototype.wield = function() {
        return "Wielding " + this.weapon;
    };
    
    Warrior.duel = function(warrior1, warrior2) {
        return warrior1.wield() + " " + warrior2.wield();
    }
