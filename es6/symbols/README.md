## Symbol

В ES6 появился новый примитивный тип данных: `symbol`. В отличии от остальных примитивных типов
он не может быть представлен в форме литерала.

Вот как он создается:

    var sym = Symbol( "необязательное описание" );
    
    typeof sym;     // "symbol"

Следует обратить внимание на три момента:

- Использовать оператор `new` с функцией `Symbol(..)` нельзя. Это не конструктор и вы создаете не объект.
- Передавать функции `Symbol(..)` параметр необязательно. Передаваемый параметр представляет собой
строку с описанием назначения символа.
- Оператор `typeof` выводит новое значение ("symbol"), которое является основным способом
идентификации символа.

Описание, если оно дается, используется исключительно для перевода представления символа в строку:

    sym.toString();     // "Symbol(какое-то необязательное описание)"

Аналогично тому, как примитивные строковые значения не являются экземплярами класса `String`,
символы - не экземпляры класса `Symbol`.

Символ допускается использовать в объектах в качестве имени свойства/ключа, например особого свойства,
которое будет интерпретироваться как скрытое или как метасвойство. Но важно понимать, что, вопреки
вашим намерениям, на самом деле оно не будет ни скрытым, ни неизменяемым.

Рассмотрим модуль, реализующий поведение *шаблона одиночки* (singleton), то есть такого, который
можно создать всего один раз:

    const INSTANCE = Symbol( "instance" );
    
    function HappyFace() {
        if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];
        
        function smile() { .. }
        
        return HappyFace[INSTANCE] = {
            smile: smile
        };
    }
    
    const me = HappyFace();
    const you = HappyFace();
    
    me === you;     // true

Символьное значение `INSTANCE` в данном случае представляет собой почти скрытое свойство, напоминающее
метасвойство, которое статически хранится в объекте-функции `HappyFace()`.

В качестве альтернативы можно было воспользоваться обычным свойством `__instance` и получить аналогичное
поведение. Применение символа попросту улучшает стиль метапрограммирования, поскольку позволяет хранить
свойство `INSTANCE` отдельно от остальных, обычных свойств.

___

### Реестр символов

Использование символов имеет свои особенности. Скажем, в последнем фрагменте кода переменную `INSTANCE`
пришлось сохранить во внешней области видимости (и даже в глобальной), потому что они должны были
находиться в открытом доступе для всех частей кода, которым они могли потребоваться.

Чтобы дать доступ к символам, их значения следует создать в *глобальном реестре* (global symbol
registry). Например:

    const EVT_LOGIN = Symbol.for( "event.login" );
    
    console.log( EVT_LOGIN );       // Symbol(event.login)

И еще:

    function HappyFace() {
        const INSTANCE = Symbol.for( "instance" );
        
        if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];
        
        // ...
        
        return HappyFace[INSTANCE] = { .. };
    }

Метод `Symbol.for(..)` проверяет в глобальном реестре, хранится ли там символ с заданным описанием,
и, обнаружив, возвращает его, а в противном случае - создает. Другими словами, глобальный реестр
интерпретирует значение символов по тексту описания.

Одновременно это означает, что любая часть приложения может затребовать символ из реестра с помощью
метода `Symbol.for(..)` при условии, что имя описания совпадает.

Восстановить текст описания (ключ) зарегестрированного символа позволяет метод `Symbol.keyFor(..)`:

    const s = Symbol( "something cool" );
    
    const desc = Symbol.keyFor( s );
    console.log( desc );                // "Something cool"
    
    // снова получим символ из реестра
    const s2 = Symbol.for( desc );
    
    s2 === s;                           // true

___

### Символы как свойства объектов

Символ, который используется как свойство/ключ объекта, сохраняется особым образом и не отображается
при обычном перечислении свойств:

    const o = {
        foo: 42,
        [ Symbol( "bar" ) ]: "hello world",
        baz: true
    };
    
    Object.getOwnPropertyNames( o );    // [ "foo", "baz" ]

Вот способ, позволяющий получить символьное свойство объекта:

    Object.getOwnPropertySymbols( o );      // [ Symbol(bar) ]

___

### Встроенные символы

В ES6 существует ряд предопределенных, встроенных символов, обеспечивающих различные поведения
значениям объектов JavaScript. Но эти символы отсутствуют в глобальном реестре.

Они хранятся как свойства объекта-функции `Symbol`.

    const a = [1,2,3];
    
    a[Symbol.iterator];     // native function

Для ссылки на эти встроенные символы в спецификации используется префикс `@@`. Вот наиболее
распространенные вырианты: `@@iterator`, `@@toStringTag`, `@@toPrimitive`. В стандарте
определены и другие встроенные символы, но они используются довольно редко.
