### Карты

Если вы давно программируете на JS, то знаете, что объекты - это основной механизм для создания структур данных,
представляющий собой неупорядоченные пары "ключ/значение", также известных как карты. При этом основной
недостаток применения объектов в качестве карт - невозможность взять в качестве ключа нестроковое значение.

Рассмотрим пример:

    var m = {};
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m[x] = "foo";
    m[y] = "bar";
    
    m[x];                   // "bar"
    m[y];                   // "bar"

Что здесь происходит? Оба объекта `x` и `y` превращены с строки "[object Object]", так что в объекте `m` будет
задан только один этот ключ.

Ранее имитация карт иногда реализовывалась поддержкой параллельного массива нестроковых значений наряду с
массивом значений. Например:

    var keys = [], vals = [];
    
    var x = { id: 1 },
        y = { id: 2 };
    
    keys.push( x );
    vals.push( "foo" );
    
    keys.push( y );
    vals.push( "bar" );
    
    keys[0] === x;              // true
    vals[0];                    // "foo"
    
    keys[1] === y;              // true
    vals[1];                    // "bar"

Разумеется, вряд ли вы захотите управлять этими параллельными массивами вручную, значит, нужно определить
структуру данных с методами, которые будут осуществлять управление автоматически. Но кроме необходимости
программировать все это лично, недостатком является еще тот факт, что вместо постоянного времени доступа
O(1) мы получали линейное, то есть O(n).

Теперь благодаря ES6 больше этого делать не требуется! Достаточно воспользоваться объектом `Map(...)`:

    var m = new Map();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    m.set( y, "bar" );
    
    m.get( x );                 // "foo"
    m.get( y );                 // "bar"

Едитнственный недостаток - отсутствие возможности использовать синтаксис квадратных скобок `[]` для задания
и извлечения значений. Но с этой работой удовлетворительно справляются методы `get(..)` и `set(..)`.

Для удаления элемента из карты применяется не оператор `delete`, а метод `delete(..)`.

    m.set( x, "foo" );
    m.set( y, "bar" );
    
    m.delete( y );

Содержимое всей карты удаляется методом `clear()`. Для получения информации о длине карты (то есть о количесве
ключей) используется свойство `size` (а не `length`).

    m.set( x, "foo" );
    m.set( y, "bar" );
    m.size;                     // 2
    
    m.clear();
    m.size;                     // 0

Конструктор `Map(..)` также может получать итерируемый объект, который должен сгенерировать список массивов,
причем первый элемент каждого будет ключом, а второй значением. Такой формат итераций идентичен
генерируемому методом `entries()`. В результвте очень просто получить копию карты:

    var m2 = new Map( m.entries() );
    
    // то же самое, что и:
    var m2 = new Map( m );

Так как экземпляр карты - итерируемый, а итератор, который используется в нем по умолчанию, такой же, как
в методе `entries()`, более предпочтительная вторая, короткая форма.

Разумеется, в конструкторе `Map()` можно просто вручную список элементов (массив ключа / массивы значений):

    var x = { id: 1 },
        y = { id: 2 };
    
    var m = new Map( [
        [ x, "foo" ],
        [ y, "bar" ]
    ] );
    
    m.get( x );                 // "foo"
    m.get( y );                 // "bar"

#### Значения карт

Для получения списка значений карты применяется метод `values(..)`, возвращающий итератор.

Рассмотрим пример:

    var m = new Map();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    m.set( y, "bar" );
    
    var vals = [ ...m.values() ];
    
    vals;                               // ["foo","bar"]
    Array.from( m.values() );           // ["foo","bar"]

Как упоминалось в предыдущем разделе, элементы карты можно циклически просматривать с помощью метода
`entries()` (или встроенного итератора карты). Например:

    var m = new Map();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    m.set( y, "bar" );
    
    var vals = [ ...m.entries() ];
    
    vals[0][0] === x;                   // true
    vals[0][1];                         // "foo"
    
    vals[1][0] === y;                   // true
    vals[1][1];                         // "bar"

#### Ключи карт

Для получения списка ключей карты используется метод `keys()`, возвращающий итератор.

    var m = new Map();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    m.set( y, "bar" );
    
    var keys = [ ...m.keys() ];
    
    keys[0] === x;                  // true
    keys[1] === y;                  // true

Чтобы узнать, есть ли в карте конкретный ключ, используйте метод `has(..)`.

    var m = new Map();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    
    m.has( x );                     // true
    m.has( y );                     // false

По сути, карты позволяют ассоциировать дополнительную информацию (значение) с объектом (ключом), не
добавляя ее к самому объекту.

В качестве ключа карты может использоваться любое значение, но, как правило, это объекты, так как
строки и другие примитивы уже зарезервированы в качестве ключей обычных объектов. Другими словами, вы,
скорее всего, станете использовать для карт объекты, кроме случаев, когда некоторые или все ключи не
должны быть объектами и поэтому больше подходят карты.

Если в качестве ключа карты используется объект, который позднее оказывается удаленным (исчезают все
ссылки на него), для освобождения памяти при проходе сборщика мусора, карта все равно будет возвращать
эту запись. Чтобы сделать запись карты доступной для сборщика мусора, потребуется ее удаление. В следующем
разделе мы рассмотрим более подходящий на роль ключа объект `WeakMap`.

___

### Объекты WeakMap

Существует "слабая" вариация карты - объект `WeakMap`, обладающий таким же внешним поведением, но
отличающийся тем, как под него выделяется память (и, в частности, как работает механизм сбоки мусора).

Слабые карты принимают в качестве ключей только объекты, и те удерживаются *слабо*: если такой объект
удаляется сборщиком мусора, то удаляется и соответствующая запись в коллекции `WeakMap`. Но это не
внешнее поведение, поскольку сборщик мусора подбирает только те объекты, на которые нет ни одной
ссылки, - то есть вы не можете проверить, существует ли такой объект в коллекции `WeakMap`.

Во всем остальном, API для слабых ссылок аналогичен, хотя и обладает дополнительными ограничениями.

    var m = new WeakMap();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    m.set( x, "foo" );
    
    m.has( x );                     // true
    m.has( y );                     // false

У коллекции `WeakMap` отсутствует свойство `size` и метод `clear()`, а еще нет итераторов для ключей,
значений или элементов. Так что даже если вы сбросите ссылку `x`, что приведет к удалению соответствующей
записи из коллекции `m` посредством сборщика мусора, определить, что именно происходит, будет невозможно.
Вам останется только надеятся, что все пройдет нужным образом.

Объекты `WeakMap`, как и объекты `Map`, позволяют мягко связывать информацию с объектом. Но особенно полезны
они бывают в случае с объектами, которые вы не можете полностью контролировать, например с элементами
DOM. Если объект, используемый вами в качестве ключа карты, допускает удаление и должен быть доступным
для сборщика мусора, вам больше подойдет `WeakMap`.

Важно заметить, что коллекция `WeakMap` слабо удерживает только ключи, но не значения. Рассмотрим пример:

    var m = new WeakMap();
    
    var x = { id: 1 },
        y = { id: 2 },
        z = { id: 3 },
        w = { id: 4 };
    
    m.set( x, y );
    
    x = null;                       // { id: 1 } доступен для сборщика мусора
    y = null;                       // { id: 2 } доступен для сборщика мусора
                                    // только потому, что { id: 1 }
    
    m.set( z, w );
    
    w = null;                       // { id: 4 } недоступен для сборщика мусора

___

### Объекты Set

Объекты `Set` представляют собой коллекции уникальных значений (дубликаты здесь игнорируются).

API для них примерно такой же, как для карт. Вместо метода `set(..)` используется метод `add(..)` (что
выглядит несколько забавно), а метод `get(..)` вообще отсутствует.

Рассмотрим пример:

    var s = new Set();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    s.add( x );
    s.add( y );
    s.add( x );
    
    s.size;                         // 2
    
    s.delete( y );
    s.size;                         // 1
    
    s.clear();
    s.size;                         // 0

Конструктор `Set(..)` напоминает конструктор `Map(..)`, так как может принимать итерируемый объект, например
другой объект `set` или массив значений.

Но если конструктор `Map(..)` ожидает список элементов (массив ключа / массивы значений), то конструктору
`Set(..)` нужен только список значений (массив значений):

    var x = { id: 1 },
        y = { id: 2 };
    
    var s = new Set( [x,y] );

Метод `get(..)` этой коллекции не требуется, так как элементы оттуда не извлекаются, а всего лишь проверяется
наличие или отсутствие какого-либо из них с помощью метода `has(..)`:

    var s = new Set();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    s.add( x );
    
    s.has( x );                 // true
    s.has( y );                 // false

#### Итераторы коллекции Set

Коллекция `Set` обладает темы же методами итератора, что и карты. Поведение этих методов отличается, хотя его
можно до некоторой степени назвать симметричным.

Рассмотрим пример:

    var s = new Set();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    s.add( x ).add( y );
    
    var keys = [ ...s.keys() ],
        vals = [ ...s.values() ],
        entries = [ ...s.entries() ];
    
    keys[0] === x;
    keys[1] === y;
    
    vals[0] === x;
    vals[1] === y;
    
    entries[0][0] === x;
    entries[0][1] === x;
    entries[1][0] === y;
    entries[1][1] === y;

В коллекциях `Set` итераторы `keys()` и `values()` дают список уникальных значений. Итератор `entries()`
предоставляет список массивов записей, в котором обя элемента массива представляют собой уникальное
значение коллекции. По умолчанию для коллекции `Set` имспользуется итератор `values()`.

Наиболее востребованное свойство этих коллекций - уникальность входящих в них элементов. Рассмотрим пример:

    var s = new Set( [1,2,3,4,"1",2,4,"5"] ),
        uniques = [ ...s ];
    
    uniques;                // [1,2,3,4,"1","5"]

Из-за условия уникальности приведение типов здесь оказывается невозможным, и поэтому 1 и "1" рассматриваются
как разные значения.

___

### WeakSet

Если коллекции `WeakMap` слабо держат свои ключи (цепляясь при этом за значения), то коллекции `WeakSet`
слабо держат значения (ключей у них просто нет).

    var s = new WeakSet();
    
    var x = { id: 1 },
        y = { id: 2 };
    
    s.add( x );
    s.add( y );
    
    x = null;                   // `x` доступен для сборщика мусора
    y = null;                   // `y` доступен для сборщика мусора

Значениями коллекции `WeakSet` могут быть только объекты, но ни в коем случае не примитивы, допустимые в
коллекциях `set`.