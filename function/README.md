## Функции

### Определение

**Функции** - это объекты высшего порядка, и поэтому их также можно:

1. Создавать с помощью литералов.
2. Присваивать переменным, элементам массива и свойствам других объектов.
3. Передавать в качестве аргументов другим функциям.
4. Возвращать в качестве значений из других функций.

Все, что допускается делать с объектами, можно делать и с функциями. Функции являются объектами, наделенными
особенностью *вызываться*.

___

### Способы определения функции

Двумя наиболее распространенными способами определения функций в JavaScript являются:

1. Обьявление функции (function declaration - `function func(){...}`). Функция доступна по всей области
видимости, даже до её определения.
2. Функциональное выражение (functional expression - `const func = function(){...}`). Функция доступна
только после её определения.

___

### Аргументы и параметры функций

**Параметр** - это переменная, которая указывается как часть определения функции.

**Аргумент** - это значение, которое передается функции при её вызове.

___

### Способы вызова функций

Оказывается, что способ вызова функции существенно влияет на порядок выполнения кода в ней и особенно на
установку параметра *this*. Существует четыре способа вызова функции, каждому из которых присущи свои
особенности:

1. **Как функция**. Например, `getDate()` - это функция, вызываемая непосредственно.
2. **Как метод**. Например, вызов `user.getName()` тесно связан с объектом, допуская объектно-ориентированное
программирование.
3. **Как конструктор**. Например, в операции `new Person()` создается новый объект.
4. **Через методы** `apply()` **и** `call()` **отдельной функции**. Например, `say.call(user)`
или `getPassword.apply(admin)`.

___

### Call, apply и bind

Метод `call()` вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

Метод `apply()` вызывает функцию с указанным значением `this` и аргументами, предоставленными в виде массива.

Синтаксис этих функций практически полностью идентичен, единственная разница заключается в том, что
функция `call()` принимает список аргуметов, а функция `apply()` принимает единичный массив аргументов.

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения
`this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены
перед переданными в привязанную функцию аргументами при её вызове.

Простейшим способом использования `bind()` является создание функции, которая, вне зависимости от
способа её вызова, вызывается с определённым значением `this`. Обычным заблуждением для новичков в JavaScript
является извлечение метода из объекта с целью его дальнейшего вызова в качестве функции и
ожидание того, что он будет использовать оригинальный объект в качестве своего значения
`this` (например, такое может случиться при использовании метода как функции обратного вызова).
Однако, без специальной обработки, оригинальный объект зачастую теряется. Создание привязанной функции
из функции, использующей оригинальный объект, изящно решает эту проблему:

    this.x = 9;
    var module = {
      x: 81,
      getX: function() { return this.x; }
    };
    
    module.getX(); // 81
    
    var getX = module.getX;
    getX(); // 9, поскольку в этом случае this ссылается на глобальный объект
    
    // создаём новую функцию с this, привязанным к module
    var boundGetX = getX.bind(module);
    boundGetX(); // 81

Следующим простейшим способом использования `bind()` является создание функции с предопределёнными аргументами.
Эти аргументы (если они есть) передаются после значения `this` и вставляются перед аргументами, передаваемыми в
целевую функцию при вызове привязанной функции.

    function list() {
      return Array.prototype.slice.call(arguments);
    }
    
    var list1 = list(1, 2, 3); // [1, 2, 3]
    
    // Создаём функцию с предустановленным ведущим аргументом
    var leadingThirtysevenList = list.bind(undefined, 37);
    
    var list2 = leadingThirtysevenList(); // [37]
    var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
