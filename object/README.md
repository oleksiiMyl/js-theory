## Объекты, методы объектов и this

### this

**this** - ссылка на объект, с которым она связывается, в момент вызова функции.
То, на что ссылается **this**, определяется исключительно местом вызова, из которого была вызвана функция.

Типы связывания по приоритету:
1. Связывание `new`. Используется только что сконструированный объект.
2. Явное связывание. Используется объект, который передается в `call`, `apply` или `bind`.
3. Неявное связывание. Используется объект, в контексте которого была вызвана функция.
4. Связывание по умолчанию. Используется глобальный объект, если не `strict` режим, `undefined` в противном случае.

___

### Дескрипторы

Дескрипторы свойств объекта:
1. `writable` - Определяет возможность изменения значения свойства.
2. `configurable` - Запрещает последующий вызов `defineProperty` для текущего свойства.
Попытка вызова будет приводить к ошибке `TypeError` (Есть одно исключение: даже если значению этого
дескриптора задано `false`, характеристика `writable` всегда может быть переключена из `true` в `false` без
выдачи ошибки, но не наоборот). Также `configurable: false` блокирует возможность использования оператора
`delete` для удаления существующего свойства.
3. `enumerable` - Управляет тем, должно ли свойство включаться в перечисление свойств объекта,
например, в циклах `for..in`.

Создание свойства с использованием дескриптора:

    Object.defineProperty(someObject, “a”, {
        value: 2,
        writable: true,
        configurable: true,
        enumerable: true
    });

Получение дескрипторов свойства:

    const myObject = {
        a: 2
    };

    Object.getOwnPropertyDescriptor(myObject, “a”);
    // {
    // 	value: 2,
    //	writable: true,
    //	enumerable: true,
    //	configurable: true
    // }
    
`Object.preventExtensions(someObject)` - запрет возможности добавления новых свойств в объект, старые
свойства работают без изменений.

`Object.seal(someObject)` - вызывает для текущего объекта `Object.preventExtensions(..)`, но так же
существующие свойства получают пометку `configurable: false`.

`Object.freeze(someObject)` - вызывает для ткущего объекта `Object.seal(..)`, но также все свойства
доступа к данным получают пометку `writable: false`.

___

### __proto__ vs Prototype

`__proto__` - есть у любого объекта

`Protorype` - есть у `class` (синтаксический сахар над функцией) либо `function`

`__proto__` - любого объекта ссылается на `prototype` класса (функции-конструктора), с помощью которой
этот объект был создан (сконструирован)

___

### Внутренние свойства объектов

`[[Get]]` - используется для получения свойства у объекта, если не находит, поднимается по цепочке прототипов.
Если не находит, возвращает `undefined`.

`[[Put]]` - выполняется в несколько этапов:
1. Проверяет, является ли свойство дескриптором функции доступа. В таком случае вызывается Set-функция,
если она существует.
2. Свойство является дескриптором данных с характеристикой `writable: false`? В таком случае происходит
незаметный сбой, а в режиме `strict` выдается ошибка `TypeError`.
3. В остальных случаях значение присваивается существующему свойству.

`[[Prototype]]` - ссылка на другой объект, которая используется, если не удается найти свойство или метод
в текущем объекте.

`[[Call]]` - внутреннее свойство обьекта, которое позволяет активизировать его посредством вызова
(`function` содержит это свойство).

`[[Class]]` - значение этого свойства можно посмотреть, вызвав метод по умолчанию `Object.prototype.toString()`
для необходимого значения. В большинстве случаев внутреннее значение `[[Class]]` соответствует стандартному
конструктору, который связан с этим значением. Например для числа - `“[object Number]”` и т.д.
Хотя встроенных конструкторов `Null()` или `Undefined()` не существует, но тем не менее они входят в число
внутренних значений `[[Class]]` (`“[object Null]”`, `“[object Undefined]”`).

___

### Геттеры и Сеттеры

Стандартные операции объектов `[[Put]]` и `[[Get]]` полностью контролируют как значения задаются для
существующих или новых свойств и, соответственно, запрашиваются из существующих свойств.

ES5 представил способ переопределения части этих стандартных операций не на уровне объекта, а на уровне свойств,
через использование *геттеров* и *сеттеров*. **Геттеры** -- это свойства, которые на самом деле вызывают скрытую
функцию для получения значения. **Сеттеры** -- это свойства, которые на самом деле вызывают скрытую функцию
для задания значения.

Когда вы задаете свойству *геттер* или *сеттер*, оно определяется как «дескриптор доступа»
(в противовес «дескриптору данных»). Для дескрипторов доступа, характеристики дескриптора
`value` и `writable` игнорируются, а вместо этого JS рассматривает характеристики свойства
`set` и `get` (а также `configurable` и `enumerable`).

Рассмотрим:

    var myObject = {
        // определяем геттер для `a`
        get a() {
            return 2;
        }
    };
    Object.defineProperty(
        myObject,       // цель
        "b",            // имя свойства
        {	// дескриптор
            // определяем геттер для `b`
            get: function(){ return this.a * 2 },
            // убедимся что `b` будет отображаться как свойство объекта
            enumerable: true
        }
    );
    myObject.a; // 2
    myObject.b; // 4

Как в объектно-литеральном синтаксисе с использованием `get a() { .. }`, так и с помощью явного определения
через `defineProperty(..)` мы создали свойство объекта, которое на самом деле не содержит значение,
но доступ к которому приводит к вызову функции-геттера, чьё возвращаемое значение и будет результатом
обращения к свойству.

    var myObject = {
        // определяем геттер для `a`
        get a() {
            return 2;
        }
    };
    myObject.a = 3;
    myObject.a; // 2

Поскольку мы определили геттер для `a`, то если мы попытаемся установить значение `a`, операция не выдаст
ошибки, а молча отбросит присваивание. Даже если бы тут был валидный сеттер, в нашем геттере жестко
прописано вернуть только `2`, так что операция присваивания будет спорной.

Чтобы сделать этот сценарий более разумным, свойства должны быть заданы с помощью сеттеров, которые
переопределяют стандартную операцию `[[Put]]` (известную как присваивание) для каждого свойства, как вы
того и ожидали. Скорее всего вы захотите всегда объявлять и геттер и сеттер (наличие только первого
или второго часто приводит к непредсказуемому/удивительному поведению):

    var myObject = {
        // определим геттер для `a`
        get a() {
            return this._a_;
        },
        // определим сеттер для `a`
        set a(val) {
            this._a_ = val * 2;
        }
    };
    myObject.a = 2;
    myObject.a; // 4

**Примечание:** В этом примере мы на самом деле сохраняем указанное значение присваивания 2 (операция `[[Put]]`)
в другой переменной `_a_`. Имя `_a_` здесь чисто для примера и не означает никакого особенного
поведения -- это обычное свойство, как и любое другое.

___

### Существование

Запрос свойства вроде `myObject.a` может вывести значение `undefined` как в случае, когда там явно задано
`undefined`, так и в случае, когда свойство a вообще не существует. Если в обоих случаях значение одинаково,
как же нам их различить?

Мы можем спросить есть ли у объекта свойство, не запрашивая значение свойства:

    var myObject = {
        a: 2
    };
    ("a" in myObject);                  // true
    ("b" in myObject);                  // false
    myObject.hasOwnProperty( "a" );     // true
    myObject.hasOwnProperty( "b" );     // false

Оператор `in` проверит находится ли свойство в объекте или существует ли оно уровнем выше в
цепочке `[[Prototype]]` объекта. `hasOwnProperty(..)` наоборот проверяет есть ли свойство только у объекта
`myObject` или нет и не опрашивает цепочку `[[Prototype]]`.

Метод `hasOwnProperty(..)` доступен для всех нормальных объектов через делегирование `Object.prototype`.
Но можно создать объект, который не привязан к `Object.prototype` (с помощью `Object.create(null)`).
В этом случае, вызвать метод `myObject.hasOwnProperty(..)` не получится.

При таком сценарии более надежным способом выполнить подобную проверку будет
`Object.prototype.hasOwnProperty.call(myObject,"a")`, который заимствует базовый метод `hasOwnProperty`
и использует явную привязку `this`, чтобы применить его к нашему `myObject`.

___

### Перечисление

    var myObject = { };
    Object.defineProperty(
        myObject,
        "a",
        // сделаем `a` перечисляемой, как обычно
        { enumerable: true, value: 2 }
    );
    Object.defineProperty(
    myObject,
        "b",
        // сделаем `b` НЕперечисляемой
        { enumerable: false, value: 3 }
    );
    myObject.b;                     // 3
    ("b" in myObject);              // true
    myObject.hasOwnProperty( "b" ); // true
    // .......
    for (var k in myObject) {
        console.log( k, myObject[k] );
    }
    // "a" 2

Вы заметите, что `myObject.b` по факту существует и имеет доступное значение, но оно не отображается в
цикле `for..in` (хотя, внезапно, оно обнаружилось проверкой на существование оператором `in`). Всё потому,
что по сути «перечислимое» означает «будет учтено, если пройти перебором по свойствам объекта»).

Еще один способ определить перечисляемые и неперечисляемые свойства:

    var myObject = { };
        Object.defineProperty(
        myObject,
        "a",
        // сделаем `a` перечисляемым, как обычно
        { enumerable: true, value: 2 }
    );
    Object.defineProperty(
        myObject,
        "b",
        // сделаем `b` неперечисляемым
        { enumerable: false, value: 3 }
    );
    myObject.propertyIsEnumerable( "a" );   // true
    myObject.propertyIsEnumerable( "b" );   // false
    Object.keys( myObject );                // ["a"]
    Object.getOwnPropertyNames( myObject ); // ["a", "b"]

`propertyIsEnumerable(..)` проверяет существует ли данное имя свойства непосредственно в объекте и установлено
ли `enumerable: true`.

`Object.keys(..)` возвращает массив всех перечисляемых свойств, в то время как `Object.getOwnPropertyNames(..)`
возвращает массив всех свойств -- перечисляемых или нет.

Отличия `in` от `hasOwnProperty(..)` в том, опрашивают ли они цепочку `[[Prototype]]` или нет.
В то время как `Object.keys(..)` и `Object.getOwnPropertyNames(..)` проверяют только конкретный указанный объект.

Не существует (пока) встроенного способа получить список всех свойств, эквивалентного тому, как опрашивает
оператор `in` (перебирая все свойства по всей цепочке `[[Prototype]]`). Приблизительно, такой инструмент
можно сделать, если рекурсивно перебирать цепочку `[[Prototype]]` объекта и на каждом уровне выбирать
список из `Object.keys(..)` -- только перечисляемых свойств.

___

## Полезные ссылки:
1. В этом [видео](https://www.youtube.com/watch?v=b55hiUlhAzI) более подробно и доступно обьясняется
разница между `__proto__` и `prototype`.



