## Преобразование типов

Преобразование значения от одного типа к другому часто делится на *явное* и *неявное*.

Может это и не очевидно, но преобразования в JavaScript всегда дают одно из скалярных примитивных значений, такое
как строка, число или логическое значение. Не существует преобразования, которое бы давало сложное значение
(например, объект или функцию). При попытке вызова метода у примитивного значения, осуществляется "упаковака" -
заключение примитивных значений в их объектные аналоги, но процесс упаковки не является преобразованием типа
в точном смысле.

Различия между ними должны быть очевидны: "явное преобразование типа" происходит тогда, когда из кода становится
ясно, что тип преобразуется намеренно, тогда как "неявное преобразование" выполняется тогда, когда оно является
менее очевидным побочным эффектом другой явной операции.

Например:

    var a = 42;
    
    var b = a + "";         // неявное преобразование
    
    var c = String( a );    // явное преобразование

___

### Абстрактные операции

Прежде чем разбираться в явных и неявных преобоазованиях, необходимо изучить базовые правила, управляющие тем, как
значения превращаются в строки, числа или логические значения. Спецификация ES5 в разделе 9 определяет несколько
"абстрактных операций" с правилами преобразования значений. Особое внимание будет уделено **ToString**,
**ToNumber** и **ToBoolean**, и в меньшей степени **ToPrimitive**.

#### ToString

Когда любое нестроковое значение преобразуется в строковое представление, преобразование выполняется абстрактной
операцией **ToString** из раздела 9.8 спецификации.

Встроенные примитивные значения содержат естественное преобразование к строковому виду: `null` превращается в
`"null"`, `undefined` превращается в `"undefined"`, `true` превращается в `"true"`. Числа обычно выражаются
в естественном виде, привычном нам, но очень малые или очень большие числа представляются в экспоненциальной форме:

    // 1.07 умножается на 1000 семь раз
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
    
    // семь раз по три цифры = 21 цифра
    a.toString(); // "1.07e21"

Для обычных объектов, если только вы не укажете собственную реализацию, реализация `toString()` возвращает
внутренний `[[Class]]`, например `"[objectObject]"`.

Но если объект содержит собственный метод `toString()` и этот объект используется в строковом контексте,
автоматически будет вызвана его реализация `toString()` и будет использован строковый результат этого вызова.

Массивы имеют переопределенную версию по умолчанию `toString()`, которая выполняет (строковую) конкатенацию всех
своих значений (каждое из которых также преобразуется к строковой форме), разделяя их ",":

    var a = [1,2,3];
    
    a.toString();   // "1,2,3"
    
    var b = [1,2,[3,4],5,[6,[7,8]]];
    
    b.toString();   // "1,2,3,4,5,6,7,8"

И снова метод `toString()` может вызываться явно, или же он будет вызван автоматически при использовании
нестрокового значения в строковом контексте.

##### `Преобразование JSON в строку`

Метод `JSON.stringify(..)` автоматически опускает обнаружение значения `undefined`, `function`,
`symbol`. Если такое значение будет найдено в массиве, оно заменяется `null` (чтобы положение информации
в массиве не изменилось). Если значение обнаруживается в свойстве объекта, это свойство просто исключается.

Пример:

    JSON.stringify(undefined);  // undefined
    JSON.stringify(function(){});  // undefined
    JSON.stringify([1, undefined, function(){}, 4])  // “[1, null, null, 4]”
    JSON.stringify({ a: 2, b: function(){} })   //“{“a”: 2}”

Если вы собираетесь применить преобразование *JSON* к объекту, который может содержать недействительные значения
*JSON*, или если обьект содержит значения, недопустимые для сериализации, определите метод `toJSON()`,
который возвращает *JSON-безопасную* версию объекта.

    const a = {
        b: 42,
        c: function(){}
    };
    
    a.toJSON = function(){
        return { b: this.b }
    }
    
    JSON.stringify(a);  // “{“b”: 42}”

Метод `toJSON()` следует интерпретировать как “приведение к JSON-безопасному значению, подходящему для
преобразования в строку”, а не “преобразование в строку JSON”.

В `JSON.stringify(..)` может передаваться необязательный второй аргумент, который называется заменителем
(replacer). Этим аргументом может быть массив или функция. Он предназначен для настройки рекурсивной сериализации
объекта и предоставляет механизм фильтрации свойств, которые должны (или не должны) включаться в результат,
по аналогии с тем, как `toJSON()` готовит значение для сериализации. Если заменитель является массивом, это
должен быть массив строк, каждая из которых задает имя свойства, разрешенного для включения в сериализацию
объекта. Если какое-то свойство не входит в этот список, оно пропускается.

    const a = {
        b: 42,
        c: “42”,
        d: [1,2,3]
    };
    
    JSON.stringify(a, [“b”, “c”]);  // “{“b”: 42, “c”: “42”}”

Если заменитель является функцией, эта функция сначала будет вызвана для самого объекта, а затем для каждого
свойства в объекте. Каждый раз ей передается два аргумента, ключ и значение. Чтобы пропустить ключ в
сериализации, верните `undefined`. В противном случае верните значение.

    JSON.stringify(a, function(k,v) {
        if (k !== “c”) return v;
    });  // “{“b”: 42, “d”: [1,2,3]}”

В `JSON.stringify(..)` также может передаваться третий необязательный аргумент отступ, который используется для
украшения вывода. Отступ может быть положительным целым числом - тогда он указывает, сколько пробелов должно
использоваться на каждом уровне отступов. Также отступ может быть строкой; в этом случае на каждом уровне
отступов используются его начальные символы (до 10):

    JSON.stringify(a, null, 3); 
    JSON.stringify(a, null, “——”);

#### ToNumber

Если любое нечисловое значение используется в контексте, в котором оно должно быть числом (например, в
математической операции), спецификация ES5 определяет абстрактную операцию **ToNumber** в разделе 9.3.

Например, `true` преобразуется в *1*, а `false` преобразуется в *0*, `undefined` превращается в *NaN*, но
(как ни странно) `null` превращается в *0*.

Объекты (и массивы) сначала преобразуются в свои эквиваленты среди примитивных значений, а полученное значение
(если это примитив, но еще не число) преобразуется в число по только что упомянутым правилам **ToNumber**.

Чтобы выполнить преобразование к эквивалентному примитивному значению, абстрактная операция **ToPrimitive**
проверяет соответствующее значение (с использованием внутренней операции **DefaultValue**) на наличие метода
`valueOf()`. Если метод `valueOf()` доступен и возвращает примитивное значение, это значение используется для
преобразования типа. Если нет, то `toString()` предоставляет значение для преобразования (если возможно).

Если ни одна операция не может прелрставить примитивное значение, выдается ошибка **TypeError**.

В ES5 можно создать такой "непреобразуемый" объект (без `valueOf()` и `toString()`), если его `[[Prototype]]`
содержит значение `null`, обычно создаваемый вызовом `Object.create(null)`.

Пример:

    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };
    
    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN

#### ToBoolean

Все значения JavaScript можно разделить на две категории:

1. Значения, которые при преобразовании в *boolean* дают *false*.

2. Все остальные (которые, очевидно, дают *true*)

В спецификации ES5 определена абстрактная операция **ToBoolean**, которая точно говорит, что происходит со всеми
возможными значениями при попытке преобразования их в `boolean`.

Из этой таблицы мы получаем следующий список так называемых "ложных" значений:

- undefined
- null
- false
- +0, -0 и NaN
- ""

Вот и все. Если значение присутствует в списке, оно является "ложным", и при применении преобразования к
логическому типу вы получите *false*. Любое другое значения, которые не входят в этот список, являются
"истинным", и при преобразовании к логическому типу, вернет *true*.

___

### Явное преобразование типов

#### String <--> Number

Для явного преобразования между строками и числами используются встроенные функции `String(..)` и `Number(..)`,
но что очень важно - перед ними не ставится ключевое слово `new`. А это означает, что мы не создаем
объектные обертки.

Вместо этого выполняется явное преобразование между двумя типами:

    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b;  // "42"
    d;  // 3.14

`String(..)` преобразует любое другое значение в примитивное значение `string` по правилам операции
`ToString`. `Number(..)` преобразует любое другое значение в примитивное значение `number` по правилам
операции `ToNumber`.

Кроме `String(..)` и `Number(..)`, существуют и другие способы "явного" преобразования этих значений
между строками и числами:

    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;
    
    b;  // "42"
    d;  // 3.14

Вызов `a.toString()` формально можно считать явным, но здесь также кроется некоторая скрытая неявность.
`ToString()` не может вызываться для *примитивных* значений, таких как 42. По этой причине JS автоматически
"упаковывает" 42 в объектную обертку, что для объекта можно было вызвать `toString()`.

Даже если форма `+c` вам нравится, безусловно есть места, в которых она выглядит ужасно запутанной. Пример:

    var c = "3.14";
    var d = 5+ +c;
    
    d;  // 8.14

Унарный оператор `-` тоже выполняет преобразование, как и `+`, но он также меняет знак числа. Тем не менее
нельзя поставить два минуса (--) рядом друг с другом для восстановления знака, поскольку такие символы
будут интерпретированы как оператор декремента. Вместо этого нужно поставить между ними пробел:
`- -"3.14"`; это приведет к преобразованию к 3.14.

#### Занятный случай с оператором ~

Использование оператора ~ для получения результата -1 (сигнальное значение)

`~x` это то же самое, что `-(x + 1)`

    ~42  //  -(42 + 1)  ==>  -43

Это означает, что для получения единственного ложного значения `0`, существует только одно число `-1`.
Такой прием можно использовать в таких методах как `indexOf()` - так как, только при отсутствии результата поиска,
возвращается `-1`. Например:

    var a = ‘Hello’;
    ~a.indexOf(‘ol’)  // 0  ==>  false
    !~a.indexOf(‘ol’)  //  true

#### * --> Boolean

Как и в случае со `String(..)` и `Number(..)`, `Boolean(..)` позволяет явно выразить принудительное
преобразование к `ToBoolean`:

    var a = "0";
    var b = [];
    var c = {};
    
    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a );   // true
    Boolean( b );   // true
    Boolean( c );   // true
    
    Boolean( d );   // false
    Boolean( e );   // false
    Boolean( f );   // false
    Boolean( g );   // false

Подобно тому как унарный оператор `+` преобразует значение в число, унарный оператор отрицания `!` явно
преобразует значение в `boolean`. *Проблема* в том, что значение при этом переходит из истинного в ложное
и наоборот. Итак, для преобразования в `boolean` разработчики JS чаще всего используют оператор двойного
отрицания `!!`, потому что второй `!` возвращает разряд в исходное состояние:

    var a = "0";
    var b = [];
    var c = {};
    
    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    !!a;   // true
    !!b;   // true
    !!c;   // true
    
    !!d;   // false
    !!e;   // false
    !!f;   // false
    !!g;   // false

Все эти преобразования к `ToBoolean` будут выполняться неявно без `Boolean(..)` или `!!` при использовании
в логическом контексте (например, в команде `if (..) ..`). Но здесь явное приведение к `boolean` нужно для
того, чтобы более четко выразить намеренный характер преобразования к `ToBoolean`.
___

### Неявное преобразование типов

#### String <--> Number

Пример:

    var a = [1,2];
    var b = [3,4];
    
    a + b;  // "1,23,4"

Согласно спецификации, алгоритм `+` (когда операндом является значение `object`) выполняет конкатенацию, если
хотя бы один операнд уже является строкой либо следующая последовательность действий дает строковое
представление. Когда алгоритм `+` получает объект (в том числе и массив) в любом из операндов, он сначала
вызывает абстрактную операцию `ToPrimitive` для этого значения, а затем вызывает алгоритм `[[DefaultValue]]`
с контекстным указателем `number`. Эта операция идентична тому, как абстрактная операция `ToNumber` работает
с объектами. Операция `valueOf()` для массива не может выдать простой примитив, поэтому она перейдет к
представлению `toString()`. Таким образом, два массива превращаются в "1,2" и "3,4" соответственно.
После этого `+` выполняет конкатенацию двух строк, как обычно: "1,23,4".

Число можно преобразовать в строку простым "сложением" его с пустой строкой:

    var a = 42;
    var b = a + "";
    
    b;  // "42"

А как насчет другого направления? Как неявно преобразовать строку в число?

    var a = "3.14";
    var b = a - 0;
    
    b;  // 3.14

Оператор `-` определен только для числового вычитания, так что `a - 0` инициирует преобразование `a` в число.
Хотя запись `a * 1` или `a / 1` встречается намного реже, она приводит к тому же результату, так как эти
операции тоже определены только для числовых операций.

Как насчет использования объектных значений с оператором `-`? Происходит то же, что с `+` в предыдущем примере:

    var a = [3];
    var b = [1];
    
    a - b;  // 2

Значения-массивы должны стать *числами*, но они сначала будут преобразованы в *строки* (с использованием
сериализации `toString()`, как и ожидалось). Эти *строки* затем преобразуются в числа, с которыми будет
выполнено вычитание `-`.

#### * --> Boolean

Операции, которые требуют неявного преобразования к `boolean`:

1. Условие в команде `if (..)`.
2. Условие (вторая часть) в заголовке `for ( .. ; .. ; .. )`.
3. Условие в циклах `while (..)` и `do .. while (..)`.
4. Условие (первая часть) в тернарных выражениях `.. ? .. : ..`.
5. Левый операнд (который служит проверяемым условием) для операторов `||` ("логическое OR") или
`&&` ("логическое AND").

Любое значение, используемое в этих контекстах, которое не относится к типу `boolean`, будет неявно
преобразовано к `boolean` по правилам абстрактной операции `ToBoolean`.

#### Операторы || и &&

Значение, произведенное оператором `&&` или `||`, не обязательно относится к типу `Boolean`. Результирующее
значение всегда будет значением одного из двух выражений-операндов.

    var a = 42;
    var b = "abc";
    var c = null;
    
    a || b;     // 42
    a && b;     // "abc"
    
    c || b;     // "abc"
    c && b;     // null

Что касается оператора `||`, если условие истинно, то результатом выражения `||` становится значение
первого операнда. Если же условие ложно, то результатом выражения `||` становится значение второго операнда.

И наоборот, для оператора `&&`, если условие истинно, то результатом выражения `&&` становится значение
второго операнда. Если же условие ложно, то результатом выражения `&&` становится значение первого операнда.

##### `Приоритет операторов`

Самый высокий приоритет у `&&`, после него идет `||`, а затем тернарный оператор `?:`

Например:

`a && b || c ? c || b ? a : c && b : a` 

будет вычисляться как

`((a && b) || c) ? ((c || b) ? a : (c && b)) : a`

___

### Преобразование символических имен

`Symbol` можно явно преобразовать в строку, а при попытке преобразовать в строку неявно, возникнет ошибка
`TypeError`. Значения `symbol` вообще не возможно преобразовать в `number`. Но они могу явно и неявно
преобразовываться в `boolean`, результат всегда будет `true`.

___

### Равенство строгое и нестрогое

Нестрогое равенство `==` допускает преобразование типа при проверке равенства

Строгое равенство `===` запрещает преобразование типа

Правила преобразования типов при нестрогом равенстве (по спецификации ES5):

1. Если `Type(x)` относится к типу `Boolean`, вернуть результат сравнения `ToNumber(x) == y`.

2. Если `Type(y)` относится к типу `Boolean`, вернуть результат сравнения `x == ToNumber(y)`.

3. Если `x` содержит `null`, а `y` содержит `undefined`, вернуть `true`.

4. Если `x` содержит `undefined`, а `y` содержит `null`, вернуть `true`.

5. Если `Type(x)` относится с типу `String` или `Number`, a `Type(y)` относится к типу `Object`,
вернуть результат сравнения `x == ToPrimitive(y)`.

6. Если `Type(x)` относится к типу `Object`, a `Type(y)` относится с типу `String` или `Number`,
вернуть результат сравнения `ToPrimitive(x) == y`.

___


## Полезные ссылки:

1. В [этой статье](https://habr.com/ru/company/ruvds/blog/347866/) хорошо обьясняется неявное преобразование