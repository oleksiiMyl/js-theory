## Базовая терминология

### Область видимости

**Область видимости** — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены.
Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side)
ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой.

LHS-ссылки являются результатом операции присваивания. Присваивания, связанные с Областью видимости, могут
происходить либо с помощью операции `=`, либо передачей аргументов (присваиванием) параметрам функции.

JavaScript *Движок* перед выполнением сначала компилирует код, и пока он это делает, он разбивает операторы, 
подобные `var a = 2;` на два отдельных шага:

1. Первый, `var a`, чтобы объявить ее в *Область видимости*. Это выполняется в самом начале, до исполнения кода.
2. Позже, `a = 2` ищет переменную (LHS-ссылку) и присваивает ей значение, если находит.

Оба поиска ссылок LHS и RHS начинаются в текущей выполняющейся *Области видимости* и если нужно
(т.е. они не нашли что искали в ней), они работают с их более высокими вложенными *Областями видимости*,
с одной областью (этажом) за раз, ища идентификатор, пока не доберутся до глобальной (верхний этаж) и
не остановятся, вне зависимости от результата поиска.

Невыполненные RHS-ссылки приводят к выбросу `ReferenceError`. Невыполненные LHS-ссылки приводят к автоматической,
неявно созданной переменной с таким именем (если не включен "Строгий режим"), либо к `ReferenceError`
(если включен "Строгий режим").

___

### Лексическая область видимости

**Лексическая область видимости** - это статическая область в JavaScript, имеющая прямое отношение к доступу
к переменным, функциям и объектам, основываясь на их расположении в коде.

___

### Замыкание

**Замыканием** называется способность функции запоминать и получать доступ к переменным, и аргументам своей
внешней функции, даже после того, как та прекратит выполнение.

___

### Контекст выполнения

**Контекст выполнения** - это абстрактная среда, в которой JavaScript код оценивается и выполняется.
Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код
функции выполняется внутри контекста выполнения функции.

Тут может быть только один запущенный контекст выполнения (JavaScript это однопоточный язык),
который управляется стеком запросов.

Стек выполнения это стек с принципом *LIFO (Последний вошёл, первый вышел)*, в котором элементы могут
быть добавлены или удалены только сверху стека.

Запущенный контекст выполнения будет всегда сверху стека и когда запущенная функция завершится,
её контекст выполнения выкинется из стека, запустив контекст выполнения, который стоит ниже в очереди.

___

### Лексическое окружение

**Лексическое окружение** - это структура данных, которая хранит информацию по идентификаторам переменных.
Тут идентификатор обозначает имя переменных/функций, а переменная настоящий объект[включая тип функции]
или примитивное значение.

У лексического окружения есть два компонента:

1. *Запись в окружении(environment record)* это место хранятся объявления переменной или функции.
2. *Отсылка к внешнему окружению (reference to the outer environment)* означает то, что у него есть доступ
к внешнему (родительскому) лексическому окружению.

Лексическое окружение на самом деле выглядит так:

    lexicalEnvironment = {
      environmentRecord: {
        <identifier> : <value>,
        <identifier> : <value>
      }
      outer: < Reference to the parent lexical environment>
    }

___

### Hoisting

У нас есть соблазн смотреть на `var a = 2;` как на один оператор, но Движок JavaScript видит это по-другому.
Он видит `var a` и `a = 2` как два отдельных оператора, первый — как задачу фазы компиляции, а второй — как
задачу фазы выполнения.

Это приводит к тому, что все объявления в области видимости, независимо от того где они появляются,
обрабатываются первыми, до того, как сам код будет выполнен. Можно мысленно представить себе это как
объявления (переменных и функций), "переезжающие" в начало их соответствующих областей видимости, что мы
называем **"поднятие (hoisting)"**.

Сами объявления поднимаются, а присваивания, даже присваивания функциональных выражений, не поднимаются.

Как объявления функций, так и переменных поднимаются. Но тонкость (которая поможет объяснить множественные
объявления "дубликатов" в коде) в том, что сперва поднимаются функции, а затем уже переменные.


    foo(); // 1
    
    var foo;
    
    function foo() {
        console.log( 1 );
    }
    
    foo = function() {
        console.log( 2 );
    };


В то время как множественные/дублирующие объявления `var` фактически игнорируются, последовательные
объявления функции перекрывают предыдущие.

    foo(); // 3
    
    function foo() {
        console.log( 1 );
    }
    
    var foo = function() {
        console.log( 2 );
    };
    
    function foo() {
        console.log( 3 );
    }

___

## Полезные ссылки:
1. Хорошая [статья](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898)
на понимание Замыкания. Также рассказывается про лексическое окружение, контекст выполнения.